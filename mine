#!/bin/bash

#handle flags
silent=false
while getopts ":s" opt; do
 case ${opt} in
  s ) silent=true
      ;;
 esac
done

#ensure pipe
contentSrc=./cc
[[ ! -p $contentSrc ]] && mkfifo $contentSrc

#ensure fingerprint
if [ -z "$minedby" ]; then
 read -p "enter thumbprint of key to be used: " minedby
fi

#attempt to import key
if [ ! -z "$minerkey" ]; then
 if  $silent ; then
  echo -ne "$minerkey" | gpg --import >> /dev/null 2>&1
 else
  echo -ne "$minerkey" | gpg --import
 fi
fi

#test key
if ! echo 'test' | gpg --clear-sign -a -u "$minedby" >> /dev/null 2>&1 ; then
 $silent || >&2 echo "invalid signing key for $minedby"
 exit 1
fi

#todo: remove hardcoded paths
#ensure chain directory
chainDir="./chainLinks"
pendingDir="$chainDir/pending"
[ -d "$pendingDir" ] || mkdir -p "$pendingDir"

current="_"
# create genesis block if not exists
if [ -f "$chainDir/$current" ]; then
 #genisis file is solved
 currentFile="$chainDir/$current"
else
 #ensure unsolved genisis file has been created
 [ -f "$pendingDir/$current" ] || ./newBlock "$current" "$current" 3 "$minedby"  "Genesis"
 #genisis file not yet solved
 currentFile="$pendingDir/_"
fi

#get to tip
next=$current
while [ -f "$chainDir/$next" ]
do
 #verify each file; exit on failure
 if ! ./verify "$chainDir/$next" > /dev/null ; then
  #read invalid block and exit
  $silent || ./readChain "$next"
  exit 1
 fi
 current=$next
 next=$(grep -Po '(?<=proof:)[A-Za-z0-9]+' "$chainDir/$next")
done

#create next file if current is solved
if [ ! -z "$next" ]; then
 if [ ! -f "$pendingDir/$next" ]; then
  #read new content and add pending  block
  content=$(cat $contentSrc) #todo: read line <$contentSrc
  ./newBlock "$current" "$next" $lvl "$minedby"  "$content" || exit 1 #could not create new block
 fi
 current="$next"
fi

lvl=3 #todo: dynamic difficulty

function doSolve() {
 if $silent ; then
  ./solve "$1" >> /dev/null
 else
  ./solve "$1"
 fi
}

#todo: handle signals
while ( doSolve "$current" )
do

 next=$(grep -Po '(?<=proof:)[A-Za-z0-9]+' "$chainDir/$current")
 [ -z "$next" ] && exit 1 then #if solve was successful, next should be defined
 #read new content and add pending  block
 content=$(cat $contentSrc) #todo: read line <$contentSrc
 ./newBlock "$current" "$next" $lvl "$minedby"  "$content" || exit 1 #could not create new block
 current="$next"

done



#while true
#do
# if ( ./solve "$currentFile" ); then
#  next=$(grep -Po '(?<=proof:)[A-Za-z0-9]+' $currentFile)
#  [ -z "$next" ] && exit 1 then #if solve was successful, next should be defined
#  if [ -f "./chainLinks/$next" ]; then
#   #next block already solved
#   new=false
#  elif ! [ -f "./chainLinks/pending/$next" ]; then
#   #read new content and add pending  block
#   content=$(cat $contentSrc) #todo: read line <$contentSrc
#   ./newBlock "$current" "$next" $lvl "$minedby"  "$content" || exit 1 #could not create new block
#   new=true
#  fi
#  current=$next
#  if $new ; then
#   currentFile="./chainLinks/pending/$current"
#  else
#   currentFile="./chainLinks/$current"
#  fi
# else
#  exit 1 #failed to solve
# fi
#done

exit 0
##########
